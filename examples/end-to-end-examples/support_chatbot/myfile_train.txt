concat_tok_num: 981151---------------------
arrays.py</code></summary> <div class=\"highlight\"><table class=\"highlighttable\"><tr><td class=\"linenos\"><div class=\"linenodiv\"><pre><span></span><span class=\"normal\"><a href=\"#__codelineno-0-178\">178</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-179\">179</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-180\">180</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-181\">181</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-182\">182</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-183\">183</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-184\">184</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-185\">185</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-186\">186</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-187\">187</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-188\">188</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-189\">189</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-190\">190</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-191\">191</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-192\">192</a></span></pre></div></td><td class=\"code\"><div><pre><span></span><code><a id=\"__codelineno-0-178\" name=\"__codelineno-0-178\"></a><span class=\"k\">def</span> <span class=\"nf\">check_X_y</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\r\n<a id=\"__codelineno-0-179\" name=\"__codelineno-0-179\"></a>    <span class=\"sd\">\"\"\"Validate input and output data using some crucial tests.</span>\r\n<a id=\"__codelineno-0-180\" name=\"__codelineno-0-180\"></a>\r\n<a id=\"__codelineno-0-181\" name=\"__codelineno-0-181\"></a><span class=\"sd\">    Parameters</span>\r\n<a id=\"__codelineno-0-182\" name=\"__codelineno-0-182\"></a><span class=\"sd\">    ----------</span>\r\n<a id=\"__codelineno-0-183\" name=\"__codelineno-0-183\"></a><span class=\"sd\">    X : ndarray of floats</span>\r\n<a id=\"__codelineno-0-184\" name=\"__codelineno-0-184\"></a><span class=\"sd\">        The input data.</span>\r\n<a id=\"__codelineno-0-185\" name=\"__codelineno-0-185\"></a><span class=\"sd\">    y : ndarray of floats</span>\r\n<a id=\"__codelineno-0-186\" name=\"__codelineno-0-186\"></a><span class=\"sd\">        The output data.</span>\r\n<a id=\"__codelineno-0-187\" name=\"__codelineno-0-187\"></a>\r\n<a id=\"__codelineno-0-188\" name=\"__codelineno-0-188\"></a><span class=\"sd\">    \"\"\"</span>\r\n<a id=\"__codelineno-0-189\" name=\"__codelineno-0-189\"></a>    <span class=\"n\">check_length</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\r\n<a id=\"__codelineno-0-190\" name=\"__codelineno-0-190\"></a>    <span class=\"n\">check_dimension</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\r\n<a id=\"__codelineno-0-191\" name=\"__codelineno-0-191\"></a>    <span class=\"n\">check_infinity</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\r\n<a id=\"__codelineno-0-192\" name=\"__codelineno-0-192\"></a>    <span class=\"n\">check_nan</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\r\n</code></pre></div></td></tr></table></div> </details> </div> </div> <div class=\"doc doc-object doc-function\"> <h2 class=\"doc doc-heading\" id=\"sysidentpy.utils._check_arrays.check_dimension\"> <code class=\"highlight language-python\"><span class=\"n\">check_dimension</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span></code> <a class=\"headerlink\" href=\"#sysidentpy.utils._check_arrays.check_dimension\" title=\"Permanent link\">\u00b6</a></h2> <div class=\"doc doc-contents\"> <p>Check if X and y have only real values.</p> <p>If there is any string or object samples a ValueError is raised.</p> <p><strong>Parameters:</strong></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr> <td><code>X</code></td> <td> <code>ndarray of floats</code> </td> <td><p>The input data.</p></td> <td> <em>required</em> </td> </tr> <tr> <td><code>y</code></td> <td> <code>ndarray of floats</code> </td> <td><p>The output data.</p></td> <td> <em>required</em> </td> </tr> </tbody> </table> <details class=\"quote\"> <summary>Source code in <code>sysidentpy\\utils\\_check_arrays.py</code></summary> <div class=\"highlight\"><table class=\"highlighttable\"><tr><td class=\"linenos\"><div class=\"linenodiv\"><pre><span></span><span class=\"normal\"><a href=\"#__codelineno-0-132\">132</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-133\">133</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-134\">134</a></span>\r\n<span class=\"normal\"><a href=\"#__codelineno-0-135\">135
concat_tok_num: 1214545---------------------
<mechanism_info> info(const std::string& name) const {\n        if (const auto* deriv = ptr_by_key(derived_map_, name)) {\n            return *(deriv->derived_info.get());\n        }\n        else if (auto* p = ptr_by_key(info_map_, name)) {\n            return *(p->get());\n        }\n        else if (auto deriv = derive(name)) {\n            return *(deriv->derived_info.get());\n        }\n        else {\n            return unexpected(deriv.error());\n        }\n    }\n\n    // Retrieve mechanism fingerprint. The fingerprint of a derived mechanisms\n    // is that of its parent.\n    hopefully<const mechanism_fingerprint*> fingerprint_ptr(const std::string& name) const {\n        hopefully<derivation> implicit_deriv;\n        const std::string* base = &name;\n\n        if (!defined(name)) {\n            if ((implicit_deriv = derive(name))) {\n                base = &implicit_deriv->parent;\n            }\n            else {\n                return unexpected(implicit_deriv.error());\n            }\n        }\n\n        while (auto* deriv = ptr_by_key(derived_map_, *base)) {\n            base = &deriv->parent;\n        }\n\n        if (const auto* p = ptr_by_key(info_map_, *base)) {\n            return &p->get()->fingerprint;\n        }\n\n        throw arbor_internal_error(\"inconsistent catalogue map state\");\n    }\n\n    // Construct derived mechanism based on existing parent mechanism and overrides.\n    hopefully<derivation> derive(\n        const std::string& name, const std::string& parent,\n        const std::vector<std::pair<std::string, double>>& global_params,\n        const std::vector<std::pair<std::string, std::string>>& ion_remap_vec) const\n    {\n        if (defined(name)) {\n            return unexpected_exception_ptr(duplicate_mechanism(name));\n        }\n        else if (!defined(parent)) {\n            return unexpected_exception_ptr(no_such_mechanism(parent));\n        }\n\n        string_map<std::string> ion_remap_map(ion_remap_vec.begin(), ion_remap_vec.end());\n        derivation deriv = {parent, {}, ion_remap_map, nullptr};\n\n        mechanism_info_ptr new_info;\n        if (auto parent_info = info(parent)) {\n            new_info.reset(new mechanism_info(parent_info.value()));\n        }\n        else {\n            return unexpected(parent_info.error());\n        }\n\n        // Update global parameter values in info for derived mechanism.\n\n        for (const auto& kv: global_params) {\n            const auto& param = kv.first;\n            const auto& value = kv.second;\n\n            if (auto* p = ptr_by_key(new_info->globals, param)) {\n                if (!p->valid(value)) {\n                    return unexpected_exception_ptr(invalid_parameter_value(name, param, value));\n                }\n            }\n            else {\n                return unexpected_exception_ptr(no_such_parameter(name, param));\n            }\n\n            deriv.globals[param] = value;\n            new_info->globals.at(param).default_value = value;\n        }\n\n        for (const auto& kv: ion_remap_vec) {\n            if (!new_info->ions.count(kv.first)) {\n                return unexpected_exception_ptr(invalid_ion_remap(name, kv.first, kv.second));\n            }\n        }\n\n        // Update ion dependencies in info to reflect the requested ion remapping.\n\n        string_map<ion_dependency> new_ions;\n        for (const auto& kv: new_info->ions) {\n            if (auto* new_ion = ptr_by_key(ion_remap_map, kv.first)) {\n                if (!new_ions.insert({*new_ion, kv.second}).second) {\n                    return unexpected_exception_ptr(invalid_ion_remap(name, kv.first, *new_ion));\n                }\n            }\n            else {\n                if (!new_ions.insert(kv).second) {\n                    // (find offending remap to report in exception)\n                    for (const auto& entry: ion_remap_map) {\n                        if (entry.second==kv.first) {\n                            return unexpected_exception_ptr(invalid_ion_remap(name, kv.first, entry.second));\n                        }\n                    }\n                    throw arbor_internal_error(\"inconsistent catalogue ion remap state\");\n                }\n            }\n        }\n        new_info->ions = std::move(new_ions);\n\n        deriv.derived_info = std::move(new_info);\n        return deriv;\n    }\n\n    // Implicit derivation.\n    hopefully<derivation> derive(const std::string& name) const {\n        if (defined(name)) {\n            return unexpected_exception_ptr(duplicate_mechanism(name));\n        }\n\n        auto i = name.find_last_of('/');\n        if (i==std::string::npos) {\n            return unexpected_exception_ptr(no_such_mechanism(name));\n        }\n\n        std::string base = name.substr(0, i);\n        if (!defined(base)) {\n            return unexpected_exception_ptr(no_such_mechanism(base));\n        }\n\n        std::string suffix = name.substr(i+1);\n\n        const mechanism_info_ptr& info = derived_map_.count(base)? derived_map_.at(base).derived_info: info_map_.at(base);\n        bool single_ion = info->ions.size()==1u;\n        auto is_ion = [&info](const std::string& name) -> bool { return info->ions.count(name); };\n\n        std::vector<std::pair<std::string, double>> global_params;\n        std::vector<std::pair<std::string, std::string>> ion_remap;\n\n        while (!suffix.empty()) {\n            std::string assign;\n\n            auto comma = suffix.find(',');\n            if (comma==std::string::npos) {\n                assign = suffix;\n                suffix.clear();\n            }\n            else {\n                assign = suffix.substr(0, comma);\n                suffix = suffix.substr(comma+1);\n            }\n\n            std::string k, v;\n            auto eq = assign.find('=');\n            if (eq==std::string::npos) {\n                if (!single_ion) {\n                    return unexpected_exception_ptr(invalid_ion_remap(assign));\n                }\n\n                k = info->ions.begin()->first;\n                v = assign;\n            }\n            else {\n                k = assign.substr(0, eq);\n                v = assign.substr(eq+1);\n            }\n\n            if (is_ion(k)) {\n                ion_remap.push_back({k, v});\n            }\n            else {\n                char* end = 0;\n                double v_value = std::strtod(v.c_str(), &end);\n                if (!end || *end) {\n                    return unexpected_exception_ptr(invalid_parameter_value(name, k, v));\n                }\n                global_params.push_back({k, v_value});\n            }\n        }\n\n        return derive(name, base, global_params, ion_remap);\n    }\n\n    // Retrieve implementation for this mechanism name or closest ancestor.\n    hopefully<std::unique_ptr<mechanism>> implementation(arb_backend_kind kind, const std::string& name) const {\n        const std::string* impl_name = &name;\n        hopefully<derivation> implicit_deriv;\n\n        if (!defined(name)) {\n            implicit_deriv = derive(name);\n            if (!implicit_deriv) {\n                return unexpected(implicit_deriv.error());\n            }\n            impl_name = &implicit_deriv->parent;\n        }\n\n        for (;;) {\n            if (const
concat_tok_num: 1579341---------------------
n        self.RS = matplotlib.widgets.RectangleSelector(\n            self.original_image_ax, self.onselect, drawtype=\"box\")\n        matplotlib.pyplot.connect('key_press_event', self.toggle_selector)\n        matplotlib.pyplot.show()\n\n\nclass LSqEllipse():\n    \"\"\"Fits an ellipse to the 2D outline of points.\n\n\n    From:\n    @software{ben_hammel_2020_3723294,\n          author       = {Ben Hammel and Nick Sullivan-Molina},\n          title        = {bdhammel/least-squares-ellipse-fitting: v2.0.0},\n          month        = mar,\n          year         = 2020,\n          publisher    = {Zenodo},\n          version      = {v2.0.0},\n          doi          = {10.5281/zenodo.3723294},\n          url          = {https://doi.org/10.5281/zenodo.3723294}\n        }\n    \"\"\"\n    def fit(self, data):\n        \"\"\"Lest Squares fitting algorithm\n\n        Theory taken from (*)\n        Solving equation Sa=lCa. with a = |a b c d f g> and a1 = |a b c>\n            a2 = |d f g>\n\n        Args\n        ----\n        data (list:list:float): list of two lists containing the x and y data of the\n            ellipse. of the form [[x1, x2,..., xi],[y1, y2,..., yi]]\n\n        Returns\n        ------\n        coef (list): list of the coefficients describing an ellipse\n           [a,b,c,d,f,g] corresponding to ax**2+2bxy+cy**2+2dx+2fy+g\n        \"\"\"\n        x, y = np.asarray(data, dtype=float)\n\n        # Quadratic part of design matrix [eqn. 15] from (*)\n        D1 = np.mat(np.vstack([x**2, x*y, y**2])).T\n        # Linear part of design matrix [eqn. 16] from (*)\n        D2 = np.mat(np.vstack([x, y, np.ones(len(x))])).T\n\n        # forming scatter matrix [eqn. 17] from (*)\n        S1 = D1.T*D1\n        S2 = D1.T*D2\n        S3 = D2.T*D2\n\n        # Constraint matrix [eqn. 18]\n        C1 = np.mat('0. 0. 2.; 0. -1. 0.; 2. 0. 0.')\n\n        # Reduced scatter matrix [eqn. 29]\n        M = C1.I*(S1-S2*S3.I*S2.T)\n\n        # M*|a b c >=l|a b c >. Find eigenvalues and eigenvectors from this equation [eqn. 28]\n        eval, evec = np.linalg.eig(M)\n\n        # eigenvector must meet constraint 4ac - b^2 to be valid.\n        cond = 4*np.multiply(evec[0, :], evec[2, :]) - \\\n            np.power(evec[1, :], 2)\n        a1 = evec[:, np.nonzero(cond.A > 0)[1]]\n\n        # |d f g> = -S3^(-1)*S2^(T)*|a b c> [eqn. 24]\n        a2 = -S3.I*S2.T*a1\n\n        # eigenvectors |a b c d f g>\n        self.coef = np.vstack([a1, a2])\n        self._save_parameters()\n\n    def _save_parameters(self):\n        \"\"\"finds the important parameters of the fitted ellipse\n\n        Theory taken form http://mathworld.wolfram\n\n        Args\n        -----\n        coef (list): list of the coefficients describing an ellipse\n           [a,b,c,d,f,g] corresponding to ax**2+2bxy+cy**2+2dx+2fy+g\n\n        Returns\n        _______\n        center (List): of the form [x0, y0]\n        width (float): major axis\n        height (float): minor axis\n        phi (float): rotation of major axis form the x-axis in radians\n        \"\"\"\n\n        # eigenvectors are the coefficients of an ellipse in general form\n        # a*x^2 + 2*b*x*y + c*y^2 + 2*d*x + 2*f*y + g = 0 [eqn. 15) from (**) or (***)\n        a = self.coef[0, 0]\n        b = self.coef[1, 0]/2.\n        c = self.coef[2, 0]\n        d = self.coef[3, 0]/2.\n        f = self.coef[4, 0]/2.\n        g = self.coef[5, 0]\n\n        # finding center of ellipse [eqn.19 and 20] from (**)\n        x0 = (c*d-b*f)/(b**2.-a*c)\n        y0 = (a*f-b*d)/(b**2.-a*c)\n\n        # Find the semi-axes lengths [eqn. 21 and 22] from (**)\n        numerator = 2*(a*f*f+c*d*d+g*b*b-2*b*d*f-a*c*g)\n        denominator1 = (b*b-a*c) * \\\n            ((c-a)*np.sqrt(1+4*b*b/((a-c)*(a-c)))-(c+a))\n        denominator2 = (b*b-a*c) * \\\n            ((a-c)*np.sqrt(1+4*b*b/((a-c)*(a-c)))-(c+a))\n        width = np.sqrt(numerator/denominator1)\n        height = np.sqrt(numerator/denominator2)\n\n        # angle of counterclockwise rotation of major-axis of ellipse to x-axis [eqn. 23] from (**)\n        # or [eqn. 26] from (***).\n        phi =.5*np.arctan((2.*b)/(a-c))\n\n        self._center = [x0, y0]\n        self._width = width\n        self._height = height\n        self._phi = phi\n\n    @property\n    def center(self):\n        return self._center\n\n    @property\n    def width(self):\n        return self._width\n\n    @property\n    def height(self):\n        return self._height\n\n    @property\n    def phi(self):\n        \"\"\"angle of counterclockwise rotation of major-axis of ellipse to x-axis\n        [eqn. 23] from (**)\n        \"\"\"\n        return self._phi\n\n    def parameters(self):\n        return self.center, self.width, self.height, self.phi\n\n\nclass Layer():\n    \"\"\"An image loaded from file or numpy array.\n\n\n    Attributes\n    ----------\n    filename : str, default=None\n        Path to the image file.\n    arr : array_like, default=None\n        Input image as a 2D array.\n    bw : bool, default=False\n        Whether the image should be treated as greyscale.\n    image : np.ndarray\n        2D array of the image.\n    grad : np.ndarray\n        2D gradient magnitude of the image. Corresponds to local sharpness.\n    color_selector : ColorSelector\n        Matplotlib GUI generating a silhouetting mask based on user input.\n    mask : np.ndarray\n        2D boolean mask indicating the pixels consisting of the eye.\n\n    Methods\n    -------\n    load()\n        Load image if not loaded yet.\n    get_gradient(smooth=0)\n        Measure the relative focus of each pixel using numpy.gradient.\n    color_key(hue_only=False)\n        
concat_tok_num: 1852435---------------------
(null,e,null,null)}),t[Rl]=null}};function VT(e){this._internalRoot=e}VT.prototype.unstable_scheduleHydration=function(e){if(e){var t=_K();e={blockedOn:null,target:e,priority:t};for(var r=0;r<Cc.length&&t!==0&&t<Cc[r].priority;r++);Cc.splice(r,0,e),r===0&&DK(e)}};function HR(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function WT(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==\" react-mount-point-unstable \"))}function tK(){}function Ayt(e,t,r,n,o){if(o){if(typeof n==\"function\"){var s=n;n=function(){var u=ET(i);s.call(u)}}var i=Z8(t,n,e,0,null,!1,!1,\"\",tK);return e._reactRootContainer=i,e[Rl]=i.current,a0(e.nodeType===8?e.parentNode:e),Tf(),i}for(;o=e.lastChild;)e.removeChild(o);if(typeof n==\"function\"){var a=n;n=function(){var u=ET(l);a.call(u)}}var l=WR(e,0,!1,null,null,!1,!1,\"\",tK);return e._reactRootContainer=l,e[Rl]=l.current,a0(e.nodeType===8?e.parentNode:e),Tf(function(){BT(t,l,r,n)}),l}function GT(e,t,r,n,o){var s=r._reactRootContainer;if(s){var i=s;if(typeof o==\"function\"){var a=o;o=function(){var l=ET(i);a.call(l)}}BT(t,i,e,o)}else i=Ayt(r,t,e,o,n);return ET(i)}IK=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var r=Wb(t.pendingLanes);r!==0&&(cR(t,r|1),So(t,kr()),(ue&6)===0&&(rg=kr()+500,Mc()))}break;case 13:Tf(function(){var n=$l(e,1);if(n!==null){var o=Xn();oi(n,e,1,o)}}),GR(e,1)}};pR=function(e){if(e.tag===13){var t=$l(e,134217728);if(t!==null){var r=Xn();oi(t,e,134217728,r)}GR(e,134217728)}};EK=function(e){if(e.tag===13){var t=Rc(e),r=$l(e,t);if(r!==null){var n=Xn();oi(r,e,t,n)}GR(e,t)}};_K=function(){return Te};AK=function(e,t){var r=Te;try{return Te=e,t()}finally{Te=r}};SD=function(e,t,r){switch(t){case\"input\":if(gD(e,r),t=r.name,r.type===\"radio\"&&t!=null){for(r=e;r.parentNode;)r=r.parentNode;for(r=r.querySelectorAll(\"input[name=\"+JSON.stringify(\"\"+t)+'][type=\"radio\"]'),t=0;t<r.length;t++){var n=r[t];if(n!==e&&n.form===e.form){var o=$T(n);if(!o)throw Error(ft(90));aK(n),gD(n,o)}}}break;case\"textarea\":uK(e,r);break;case\"select\":t=r.value,t!=null&&Uh(e,!!r.multiple,t,!1)}};gK=MR;xK=Tf;var Dyt={usingClientEntryPoint:!1,Events:[y0,Lh,$T,dK,hK,MR]},Mb={findFiberByHostInstance:gf,bundleType:0,version:\"18.2.0\",rendererPackageName:\"react-dom\"},Ryt={bundleType:Mb.bundleType,version:Mb.version,rendererPackageName:Mb.rendererPackageName,rendererConfig:Mb.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Fl.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=vK(e),e===null?null:e.stateNode},findFiberByHostInstance:Mb.findFiberByHostInstance||_yt,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:\"18.2.0-next-9e3b772b8-20220608\"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=\"undefined\"&&(zb=__REACT_DEVTOOLS_GLOBAL_HOOK__,!zb.isDisabled&&zb.supportsFiber))try{_T=zb.inject(Ryt),Ui=zb}catch(e){}var zb;Wo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Dyt;Wo.createPortal=function(e,t){var r=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!HR(t))throw Error(ft(200));return Eyt(e,t,null,r)};Wo.createRoot=function(e,t){if(!HR(e))throw Error(ft(299));var r=!1,n=\"\",o=J8;return t!=null&&(t.unstable_strictMode===!0&&(r=!0),t.identifierPrefix!==void 0&&(n=t.identifierPrefix),t.onRecoverableError!==void 0&&(o=t.onRecoverableError)),t=WR(e,1,!1,null,null,r,!1,n,o),e[Rl]=t.current,a0(e.nodeType===8?e.parentNode:e),new UR(t)};Wo.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render==\"function\"?Error(ft(188)):(e=Object.keys(e).join(\",\"),Error(ft(268,e)));return e=vK(t),e=e===null?null:e.stateNode,e};Wo.flushSync=function(e){return Tf(e)};Wo.hydrate=function(e,t,r){if(!WT(t))throw Error(ft(200));return GT(null,e,t,!0,r)};Wo.hydrateRoot=function(e,t,r){if(!HR(e))throw Error(ft(405));var n=r!=null&&r.hydratedSources||null,o=!1,s=\"\",i=J8;if(r!=null&&(r.unstable_strictMode===!0&&(o=!0),r.identifierPrefix!==void 0&&(s=r.identifierPrefix),r.onRecoverableError!==void 0&&(i=r.onRecoverableError)),t=Z8(t,null,e,1,r!=null?r:null,o,!1,s,i),e[Rl]=t.current,a0(e),n)for(e=0;e<n.length;e++)r=n[
concat_tok_num: 2018993---------------------
GroupList\n        self.asMatch = asMatch\n        if self.asGroupList:\n            self.parseImpl = self.parseImplAsGroupList\n        if self.asMatch:\n            self.parseImpl = self.parseImplAsMatch\n\n    def parseImpl(self, instring, loc, doActions=True):\n        result = self.re_match(instring, loc)\n        if not result:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        loc = result.end()\n        ret = ParseResults(result.group())\n        d = result.groupdict()\n        if d:\n            for k, v in d.items():\n                ret[k] = v\n        return loc, ret\n\n    def parseImplAsGroupList(self, instring, loc, doActions=True):\n        result = self.re_match(instring, loc)\n        if not result:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        loc = result.end()\n        ret = result.groups()\n        return loc, ret\n\n    def parseImplAsMatch(self, instring, loc, doActions=True):\n        result = self.re_match(instring, loc)\n        if not result:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        loc = result.end()\n        ret = result\n        return loc, ret\n\n    def __str__(self):\n        try:\n            return super(Regex, self).__str__()\n        except Exception:\n            pass\n\n        if self.strRepr is None:\n            self.strRepr = \"Re:(%s)\" % repr(self.pattern)\n\n        return self.strRepr\n\n    def sub(self, repl):\n        r\"\"\"\n        Return Regex with an attached parse action to transform the parsed\n        result as if called using `re.sub(expr, repl, string) <https://docs.python.org/3/library/re.html#re.sub>`_.\n\n        Example::\n\n            make_html = Regex(r\"(\\w+):(.*?):\").sub(r\"<\\1>\\2</\\1>\")\n            print(make_html.transformString(\"h1:main title:\"))\n            # prints \"<h1>main title</h1>\"\n        \"\"\"\n        if self.asGroupList:\n            warnings.warn(\"cannot use sub() with Regex(asGroupList=True)\",\n                          SyntaxWarning, stacklevel=2)\n            raise SyntaxError()\n\n        if self.asMatch and callable(repl):\n            warnings.warn(\"cannot use sub() with a callable with Regex(asMatch=True)\",\n                          SyntaxWarning, stacklevel=2)\n            raise SyntaxError()\n\n        if self.asMatch:\n            def pa(tokens):\n                return tokens[0].expand(repl)\n        else:\n            def pa(tokens):\n                return self.re.sub(repl, tokens[0])\n        return self.addParseAction(pa)\n\nclass QuotedString(Token):\n    r\"\"\"\n    Token for matching strings that are delimited by quoting characters.\n\n    Defined with the following parameters:\n\n        - quoteChar - string of one or more characters defining the\n          quote delimiting string\n        - escChar - character to escape quotes, typically backslash\n          (default= ``None``)\n        - escQuote - special quote sequence to escape an embedded quote\n          string (such as SQL's ``\"\"`` to escape an embedded ``\"``)\n          (default= ``None``)\n        - multiline - boolean indicating whether quotes can span\n          multiple lines (default= ``False``)\n        - unquoteResults - boolean indicating whether the matched text\n          should be unquoted (default= ``True``)\n        - endQuoteChar - string of one or more characters defining the\n          end of the quote delimited string (default= ``None``  => same as\n          quoteChar)\n        - convertWhitespaceEscapes - convert escaped whitespace\n          (``'\\t'``, ``'\\n'``, etc.) to actual whitespace\n          (default= ``True``)\n\n    Example::\n\n        qs = QuotedString('\"')\n        print(qs.searchString('lsjdf \"This is the quote\" sldjf'))\n        complex_qs = QuotedString('{{', endQuoteChar='}}')\n        print(complex_qs.searchString('lsjdf {{This is the \"quote\"}} sldjf'))\n        sql_qs = QuotedString('\"', escQuote='\"\"')\n        print(sql_qs.searchString('lsjdf \"This is the quote with \"\"embedded\"\" quotes\" sldjf'))\n\n    prints::\n\n        [['This is the quote']]\n        [['This is the \"quote\"']]\n        [['This is the quote with \"embedded\" quotes']]\n    \"\"\"\n    def __init__(self, quoteChar, escChar=None, escQuote=None, multiline=False,\n                 unquoteResults=True, endQuoteChar=None, convertWhitespaceEscapes=True):\n        super(QuotedString, self).__init__()\n\n        # remove white space from quote chars - wont work anyway\n        quoteChar = quoteChar.strip()\n        if not quoteChar:\n            warnings.warn(\"quoteChar cannot be the empty string\", SyntaxWarning, stacklevel=2)\n            raise SyntaxError()\n\n        if endQuoteChar is None:\n            endQuoteChar = quoteChar\n        else:\n            endQuoteChar = endQuoteChar.strip()\n            if not endQuoteChar:\n                warnings.warn(\"endQuoteChar cannot be the empty string\", SyntaxWarning, stacklevel=2)\n                raise SyntaxError()\n\n        self.quoteChar = quoteChar\n        self.quoteCharLen = len(quoteChar)\n        self.firstQuoteChar = quoteChar[0]\n        self.endQuoteChar = endQuoteChar\n        self.endQuoteCharLen = len(endQuoteChar)\n        self.escChar = escChar\n        self.escQuote = escQuote\n        self.unquoteResults = unquoteResults\n        self.convertWhitespaceEscapes = convertWhitespaceEscapes\n\n        if multiline:\n            self.flags = re.MULTILINE | re.DOTALL\n            self.pattern = r'%s(?:[^%s%s]' % (re.escape(self.quoteChar),\n                                              _escapeRegexRangeChars(self.endQuoteChar[0]),\n                                              (escChar is not None and _escapeRegexRangeChars(escChar) or ''))\n        else:\n            self.flags = 0\n            self.pattern = r'%s(?:[^%s\\n\\r%s]' % (re.escape(self.quoteChar),\n                                                  _escapeRegexRangeChars(self.endQuoteChar[0]),\n                                                  (escChar is not None and _escapeRegexRangeChars(escChar) or ''))\n        if len(self.endQuoteChar) > 1:\n            self.pattern += (\n                '|(?:' + ')|(?:'.join(\"%s[^%s]\" % (re.escape(self.endQuoteChar[:i]),\n                                                   _escapeRegexRangeChars(self.endQuoteChar[i]))\n                                      for i in range(len(self.endQuoteChar) - 1, 0, -1)) + ')')\n\n        if escQuote:\n            self.pattern += (r'|(?:%s)' % re.escape(escQuote))\n        if escChar:\n            self.pattern += (r'|(?:%s.)' % re.escape(escChar))\n            self.escCharReplacePattern = re.escape(self.escChar) + \"(.)\"\n        self.pattern += (r')*%s' % re.escape(self.endQuoteChar))\n\n        try:\n            self.re = re.compile(self.pattern, self.flags)\n            self.reString = self.pattern\n            self.re_match = self.re.match\n        except sre_constants.error:\n            warnings.warn(\"invalid
